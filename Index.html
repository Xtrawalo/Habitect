<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Habitect: Your Home in Space</title>
    <link rel="icon" type="png" href="Logo.png">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0B1120; /* Deep space navy */
            color: #E2E8F0; /* Light slate gray */
            overflow: hidden; /* Prevent scrolling */
        }
        /* Custom scrollbar for a more futuristic feel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1E293B;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748B;
        }
        .glassmorphism {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(51, 65, 85, 0.5);
        }
        #mainCanvas:hover {
            cursor: crosshair;
        }
        .draggable-module:hover {
            cursor: grab;
        }
        .draggable-module:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="w-screen h-screen">

    <!-- Start Page -->
    <div id="start-page" class="w-full h-full flex flex-col items-center justify-center bg-slate-900/50 z-50 absolute inset-0">
        <div class="text-center p-8 glassmorphism rounded-lg shadow-2xl max-w-lg mx-auto">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/NASA_logo.svg/240px-NASA_logo.svg.png" alt="NASA Logo" class="h-32 mx-auto mb-6">
            <h1 class="text-5xl font-bold tracking-wider text-white mb-2">HABITECT</h1>
            <p class="text-slate-300 mb-8">Your Home in Space. Design and simulate the future of off-world living.</p>
            <div class="flex flex-col sm:flex-row gap-4 justify-center">
                <button id="create-new-button" class="px-8 py-4 text-lg bg-cyan-600 hover:bg-cyan-500 rounded-md font-semibold transition-colors flex-1 disabled:bg-slate-500 disabled:cursor-wait">
                    Create New Habitat
                </button>
                <button id="load-saved-button" class="px-8 py-4 text-lg bg-slate-700 hover:bg-slate-600 rounded-md font-semibold transition-colors flex-1 disabled:bg-slate-500 disabled:cursor-wait">
                    Load Saved Habitat
                </button>
            </div>
            <p id="start-page-loading" class="text-slate-400 mt-6 hidden">Connecting to database...</p>
        </div>
    </div>


    <div id="app" class="flex flex-col h-full w-full hidden">
        <!-- Header -->
        <header class="flex-shrink-0 flex items-center justify-between p-3 border-b border-slate-700/50 z-10">
            <div class="flex items-center space-x-3">
                <button id="back-to-start-button" class="p-2 text-slate-400 hover:text-white rounded-md transition-colors" title="Back to Start Menu">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <svg class="w-8 h-8 text-cyan-400" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L2 7V17L12 22L22 17V7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M2 7L12 12L22 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 12V22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                <h1 class="text-xl font-bold tracking-wider text-white">HABITECT</h1>
            </div>
            <div id="action-buttons" class="flex items-center space-x-2">
                 <button id="save-button" class="px-3 py-1.5 text-sm bg-slate-700 hover:bg-slate-600 rounded-md transition-colors">Save</button>
                 <button id="clear-button" class="px-3 py-1.5 text-sm bg-red-800 hover:bg-red-700 rounded-md transition-colors">Clear</button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow flex flex-col lg:flex-row min-h-0">
            <!-- Left Panel: Module Library -->
            <aside class="w-full lg:w-64 flex-shrink-0 p-4 space-y-4 overflow-y-auto glassmorphism z-10">
                <h2 class="text-lg font-semibold text-cyan-400">Module Library</h2>
                <div id="module-library" class="space-y-3">
                    <!-- Modules will be dynamically inserted here -->
                </div>
            </aside>

            <!-- Center Panel: 3D Canvas -->
            <div id="canvas-container" class="flex-grow relative bg-black">
                <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center bg-black/50 z-20">
                    <p class="text-lg text-white">Initializing 3D Environment...</p>
                </div>
                <!-- Three.js Canvas will be mounted here -->
            </div>
            
            <!-- Right Panel: Dashboard & AI Advisor -->
            <aside class="w-full lg:w-80 flex-shrink-0 p-4 flex flex-col space-y-4 glassmorphism z-10 overflow-y-auto">
                <div>
                    <h2 class="text-lg font-semibold text-cyan-400 mb-2">Habitat Dashboard</h2>
                    <div id="dashboard-stats" class="space-y-4 p-4 bg-slate-900/50 rounded-lg">
                        <!-- Stats will be dynamically inserted here -->
                    </div>
                </div>
                <div class="flex-grow flex flex-col min-h-0">
                    <h2 class="text-lg font-semibold text-cyan-400 mb-2">AI Layout Advisor</h2>
                    <div id="ai-advisor" class="p-4 bg-slate-900/50 rounded-lg flex-grow flex flex-col">
                        <button id="analyze-button" class="w-full py-2 bg-cyan-600 hover:bg-cyan-500 rounded-md font-semibold transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed">
                            Analyze Layout
                        </button>
                        <div id="ai-response-container" class="mt-4 text-sm text-slate-300 h-full overflow-y-auto p-2 bg-slate-800/50 rounded-md">
                            <p id="ai-placeholder">Click "Analyze Layout" to get an improvement suggestion from our AI expert.</p>
                            <div id="ai-loading" class="hidden">
                                <div class="flex items-center space-x-2">
                                    <svg class="animate-spin h-5 w-5 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <span>Analyzing... Please wait.</span>
                                </div>
                            </div>
                            <p id="ai-suggestion" class="whitespace-pre-wrap"></p>
                        </div>
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <div id="notification" class="absolute bottom-5 right-5 bg-cyan-500 text-white px-4 py-2 rounded-md shadow-lg transition-opacity duration-300 opacity-0 z-50"></div>

    <!-- Three.js and OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CORE APPLICATION STATE ---
        const state = {
            modules: [],
            selectedModuleId: null,
            stats: {
                power: 0,
                oxygen: 0,
                comfort: 0,
                crew: 0,
            }
        };

        // --- CONSTANTS & DEFINITIONS ---
        const GEMINI_API_KEY = "AIzaSyAQ1zJXWVnfCNRifG9cQmd72If5RZLWduY"; 
        const MODULE_DEFINITIONS = {
            'LAB': { name: 'Science Lab', size: [5, 3, 3], color: 0x3b82f6, stats: { power: -50, oxygen: 0, comfort: 10, crew: 2 } },
            'SLEEP': { name: 'Sleeping Quarters', size: [6, 3, 3], color: 0x84cc16, stats: { power: -10, oxygen: -5, comfort: 25, crew: 4 } },
            'GREENHOUSE': { name: 'Geodesic Greenhouse', size: [5, 4, 5], color: 0x22c55e, stats: { power: -25, oxygen: 40, comfort: 15, crew: 1 } },
            'SOLAR': { name: 'Solar Array Wing', size: [8, 0.5, 4], color: 0xf59e0b, stats: { power: 150, oxygen: 0, comfort: 0, crew: 0 } },
            'CORRIDOR': { name: 'Flexible Corridor', size: [2, 2, 6], color: 0x64748b, stats: { power: -2, oxygen: 0, comfort: 5, crew: 0 } }
        };

        // --- DOM ELEMENT REFERENCES ---
        const appDiv = document.getElementById('app');
        const canvasContainer = document.getElementById('canvas-container');
        const notificationEl = document.getElementById('notification');
        const startPage = document.getElementById('start-page');
        const createNewButton = document.getElementById('create-new-button');
        const loadSavedButton = document.getElementById('load-saved-button');
        const startPageLoading = document.getElementById('start-page-loading');
        const backToStartButton = document.getElementById('back-to-start-button');
        
        // --- 3D SCENE SETUP ---
        let scene, camera, renderer, controls, plane, raycaster, pointer;
        let selectionBox;
        
        function initThreeJS() {
            if (renderer) return; // Prevent re-initialization

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0B1120);
            scene.fog = new THREE.Fog(0x0B1120, 50, 100);

            camera = new THREE.PerspectiveCamera(50, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(10, 15, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            canvasContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2.1; // Prevent looking under the grid

            const ambientLight = new THREE.AmbientLight(0xcccccc, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(15, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground plane that receives shadows
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.9 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid
            const grid = new THREE.GridHelper(100, 50, 0x475569, 0x334155);
            scene.add(grid);

            // Interaction Plane
            plane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })
            );
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            // Setup selection box
            selectionBox = new THREE.BoxHelper(new THREE.Mesh(), 0x06b6d4);
            selectionBox.visible = false;
            scene.add(selectionBox);

            document.getElementById('loading-indicator').style.display = 'none';

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', () => {
            if (!renderer) return;
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        });

        canvasContainer.addEventListener('pointerdown', onPointerDown);
        canvasContainer.addEventListener('pointermove', onPointerMove);
        canvasContainer.addEventListener('pointerup', onPointerUp);
        canvasContainer.addEventListener('dblclick', onDoubleClick);
        canvasContainer.addEventListener('contextmenu', onContextMenu);

        window.addEventListener('keydown', (e) => {
            if (e.key === "Escape") {
                deselectModule();
            }
            if (e.key.toLowerCase() === 'r') {
                rotateSelectedModule();
            }
        });

        // --- UI RENDERING & STATE MANAGEMENT ---
        function showNotification(message) {
            notificationEl.textContent = message;
            notificationEl.classList.remove('opacity-0');
            setTimeout(() => {
                notificationEl.classList.add('opacity-0');
            }, 3000);
        }

        function renderModuleLibrary() {
            const library = document.getElementById('module-library');
            library.innerHTML = '';
            for (const type in MODULE_DEFINITIONS) {
                const def = MODULE_DEFINITIONS[type];
                const el = document.createElement('div');
                el.className = 'p-3 border border-slate-700 rounded-md bg-slate-800/50 hover:bg-slate-700/50 transition-colors draggable-module';
                el.draggable = true;
                el.dataset.moduleType = type;
                el.innerHTML = `
                    <p class="font-bold">${def.name}</p>
                    <p class="text-xs text-slate-400">‚ö°${def.stats.power} üí®${def.stats.oxygen} üòä${def.stats.comfort}</p>
                `;
                el.addEventListener('dragstart', handleDragStart);
                library.appendChild(el);
            }
        }

        function updateDashboardUI() {
            const dashboard = document.getElementById('dashboard-stats');
            const { power, oxygen, comfort, crew } = state.stats;
            dashboard.innerHTML = `
                <div title="Total Power Generation vs Consumption">
                    <p class="text-sm font-medium">‚ö°Ô∏è Power Balance</p>
                    <p class="text-xl font-bold ${power >= 0 ? 'text-green-400' : 'text-red-400'}">${power} kW</p>
                </div>
                <div title="Total Oxygen Production vs Consumption">
                    <p class="text-sm font-medium">üí® Oxygen Net</p>
                    <p class="text-xl font-bold ${oxygen >= 0 ? 'text-cyan-400' : 'text-amber-400'}">${oxygen} L/min</p>
                </div>
                <div title="Overall Crew Comfort Rating">
                    <p class="text-sm font-medium">üòä Comfort Index</p>
                    <p class="text-xl font-bold text-lime-400">${comfort}</p>
                </div>
                <div title="Total Crew Capacity">
                    <p class="text-sm font-medium">üßë‚ÄçüöÄ Crew Capacity</p>
                    <p class="text-xl font-bold text-slate-300">${crew}</p>
                </div>
            `;
        }

        function calculateStats() {
            const newStats = state.modules.reduce((acc, module) => {
                const def = MODULE_DEFINITIONS[module.type].stats;
                acc.power += def.power;
                acc.oxygen += def.oxygen;
                acc.comfort += def.comfort;
                acc.crew += def.crew;
                return acc;
            }, { power: 0, oxygen: 0, comfort: 0, crew: 0 });
            state.stats = newStats;
            updateDashboardUI();
        }

        function updateSelectionHighlight() {
            if (!selectionBox) return;

            if (state.selectedModuleId) {
                const selectedMesh = scene.children.find(c => c.userData.id === state.selectedModuleId);
                if (selectedMesh) {
                    selectionBox.setFromObject(selectedMesh);
                    selectionBox.visible = true;
                } else {
                    selectionBox.visible = false;
                }
            } else {
                selectionBox.visible = false;
            }
        }
        
        function createModuleMesh(module) {
            const group = new THREE.Group();
            const def = MODULE_DEFINITIONS[module.type];
            
            const endCapMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, metalness: 0.6, roughness: 0.5 });
            const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 });

            switch (module.type) {
                case 'GREENHOUSE': {
                    const radius = def.size[0] / 2;
                    const detail = 1; // 0 for tetrahedron, 1 for octahedron, etc.
                    const geo = new THREE.IcosahedronGeometry(radius, detail);
                    
                    const frameMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.5 });
                    const glassMaterial = new THREE.MeshStandardMaterial({ color: 0x90c5c5, transparent: true, opacity: 0.3, roughness: 0.1 });
                    
                    const glass = new THREE.Mesh(geo, glassMaterial);
                    const frame = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }));
                    
                    group.position.y = radius;
                    group.add(glass, frame);
                    break;
                }
                case 'SOLAR': {
                    const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x0a1034, metalness: 0.9, roughness: 0.3, emissive: 0x112266, emissiveIntensity: 0.3 });
                    const mastMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.5, metalness: 0.8 });
                    
                    const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 3), mastMaterial);
                    mast.position.y = 1.5;
                    group.add(mast);

                    const wing = new THREE.Group();
                    const panel1 = new THREE.Mesh(new THREE.BoxGeometry(def.size[0] / 2.2, 0.1, def.size[2]), panelMaterial);
                    panel1.position.x = def.size[0] / 4 + 0.2;
                    const panel2 = new THREE.Mesh(new THREE.BoxGeometry(def.size[0] / 2.2, 0.1, def.size[2]), panelMaterial);
                    panel2.position.x = -def.size[0] / 4 - 0.2;
                    wing.add(panel1, panel2);
                    wing.position.y = 2.5;
                    group.add(wing);
                    break;
                }
                case 'CORRIDOR': {
                    const radius = def.size[0] / 2;
                    const length = def.size[2];
                    const segments = 8;
                    const ringMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.3 });
                    const tubeMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.2, roughness: 0.8 });
                    
                    const tubeGeo = new THREE.CylinderGeometry(radius * 0.9, radius * 0.9, length, 16, segments, true);
                    const tube = new THREE.Mesh(tubeGeo, tubeMaterial);
                    
                    for(let i=0; i <= segments; i++) {
                        const ringGeo = new THREE.TorusGeometry(radius, 0.1, 8, 24);
                        const ring = new THREE.Mesh(ringGeo, ringMaterial);
                        ring.position.y = -length/2 + (length/segments) * i;
                        ring.rotation.x = Math.PI / 2;
                        tube.add(ring);
                    }
                    tube.rotation.z = Math.PI/2;
                    group.position.y = radius;
                    group.add(tube);
                    break;
                }
                case 'SLEEP': {
                    const sleepMaterial = new THREE.MeshStandardMaterial({ color: def.color, metalness: 0.8, roughness: 0.4 });
                    const radius = def.size[2] / 2;
                    const length = def.size[0];
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 24), sleepMaterial);
                    body.rotation.z = Math.PI / 2;

                    const cap1 = new THREE.Mesh(new THREE.SphereGeometry(radius, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2), endCapMaterial);
                    cap1.position.x = -length / 2;
                    cap1.rotation.z = -Math.PI / 2;

                    const cap2 = new THREE.Mesh(new THREE.SphereGeometry(radius, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2), endCapMaterial);
                    cap2.position.x = length / 2;
                    cap2.rotation.z = Math.PI / 2;
                    
                    group.add(body, cap1, cap2);

                    const windowGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                    const window1 = new THREE.Mesh(windowGeo, windowMaterial);
                    window1.position.set(length / 4, radius, 0);
                    window1.rotation.x = Math.PI/2;
                    const window2 = new THREE.Mesh(windowGeo, windowMaterial);
                    window2.position.set(-length / 4, radius, 0);
                    window2.rotation.x = Math.PI/2;
                    group.add(window1, window2);

                    group.position.y = radius;
                    break;
                }
                case 'LAB': {
                    const labMaterial = new THREE.MeshStandardMaterial({ color: def.color, metalness: 0.7, roughness: 0.5 });
                    const radius = def.size[2] / 2;
                    const length = def.size[0];
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 24), labMaterial);
                    body.rotation.z = Math.PI / 2;

                    const cap1 = new THREE.Mesh(new THREE.SphereGeometry(radius, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2), endCapMaterial);
                    cap1.position.x = -length / 2;
                    cap1.rotation.z = -Math.PI / 2;

                    const cap2 = new THREE.Mesh(new THREE.SphereGeometry(radius, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2), endCapMaterial);
                    cap2.position.x = length / 2;
                    cap2.rotation.z = Math.PI / 2;
                    
                    group.add(body, cap1, cap2);

                    const boxGeo = new THREE.BoxGeometry(1, 1.2, 0.5);
                    const boxMat = new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.9, roughness: 0.2});
                    const equipmentBox = new THREE.Mesh(boxGeo, boxMat);
                    equipmentBox.position.set(0, radius, 1);
                    group.add(equipmentBox);
                    
                    group.position.y = radius;
                    break;
                }
                default: {
                    const defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.8, roughness: 0.4 });
                    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(...def.size), defaultMaterial);
                    group.position.y = def.size[1]/2;
                    group.add(mainBody);
                    break;
                }
            }
            
            group.userData.isModule = true;
            group.userData.id = module.id;

            group.traverse(child => {
                if (child.isMesh || child.isLineSegments) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.userData.id = module.id;
                    child.userData.isModule = true;
                }
            });

            return group;
        }

        function syncSceneWithState() {
            const toRemove = scene.children.filter(child => child.userData.isModule);
            toRemove.forEach(child => scene.remove(child));

            state.modules.forEach(module => {
                const meshGroup = createModuleMesh(module);
                meshGroup.position.set(module.position.x, 0, module.position.z);
                meshGroup.rotation.y = module.rotation || 0;
                scene.add(meshGroup);
            });
            calculateStats();
            updateSelectionHighlight();
        }

        function addModule(type, position) {
            const def = MODULE_DEFINITIONS[type];
            if (!def) return;

            const newModule = {
                id: `mod_${Date.now()}`,
                type: type,
                position: { x: position.x, y: 0, z: position.z }, // Base Y position is 0, visual height is handled in mesh creation
                rotation: 0
            };
            state.modules.push(newModule);
            syncSceneWithState();
        }

        // --- INTERACTION LOGIC (SELECT, MOVE, DRAG/DROP) ---
        let moveStartPosition = null;

        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.moduleType);
            e.dataTransfer.effectAllowed = 'copy';
            deselectModule();
        }

        function deselectModule() {
            state.selectedModuleId = null;
            updateSelectionHighlight();
        }
        
        function rotateSelectedModule() {
            if (!state.selectedModuleId) return;
            const moduleState = state.modules.find(m => m.id === state.selectedModuleId);
            if (!moduleState) return;

            moduleState.rotation = (moduleState.rotation || 0) + Math.PI / 2;

            const moduleMesh = scene.children.find(c => c.userData.id === state.selectedModuleId);
            if (moduleMesh) {
                moduleMesh.rotation.y = moduleState.rotation;
                updateSelectionHighlight();
                showNotification("Module rotated.");
            }
        }

        function onDoubleClick(event) {
            event.preventDefault();

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const moduleMeshes = scene.children.filter(c => c.userData.isModule);
            const intersects = raycaster.intersectObjects(moduleMeshes, true);

            if (intersects.length > 0) {
                const objectToRemove = intersects[0].object;
                const moduleIdToRemove = objectToRemove.userData.id;

                if (state.selectedModuleId === moduleIdToRemove) {
                    deselectModule();
                }

                state.modules = state.modules.filter(m => m.id !== moduleIdToRemove);
                syncSceneWithState();
                showNotification("Module removed.");
            }
        }

        function onContextMenu(event) {
            event.preventDefault(); // Always prevent the default context menu on the canvas.

            // If a module move is in progress, cancel it by reverting to its start position.
            if (state.selectedModuleId && moveStartPosition) {
                // Revert position in the state
                const moduleState = state.modules.find(m => m.id === state.selectedModuleId);
                if (moduleState) {
                    moduleState.position.x = moveStartPosition.x;
                    moduleState.position.z = moveStartPosition.z;
                }
                
                // Sync the 3D scene to reflect the reverted position
                syncSceneWithState();

                // End the move operation cleanly, same as letting go of the mouse
                onPointerUp();
                showNotification("Move cancelled.");
            }

            // In any case where a module is selected, deselect it.
            if (state.selectedModuleId) {
                deselectModule();
            }
        }

        function onPointerDown(event) {
            if (event.button !== 0) return; // Only start drag with left-click

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const moduleMeshes = scene.children.filter(c => c.userData.isModule);
            const intersects = raycaster.intersectObjects(moduleMeshes, true);

            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                state.selectedModuleId = selectedObject.userData.id;
                controls.enabled = false;
                
                const moduleState = state.modules.find(m => m.id === state.selectedModuleId);
                if (moduleState) {
                    moveStartPosition = { x: moduleState.position.x, y: moduleState.position.y, z: moduleState.position.z };
                }
            } else {
                deselectModule();
            }
            updateSelectionHighlight();
        }

        function onPointerMove(event) {
            if (!state.selectedModuleId) return;

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                const pos = intersects[0].point;
                const snappedX = Math.round(pos.x / 2) * 2;
                const snappedZ = Math.round(pos.z / 2) * 2;
                
                const moduleState = state.modules.find(m => m.id === state.selectedModuleId);
                moduleState.position.x = snappedX;
                moduleState.position.z = snappedZ;

                const moduleMesh = scene.children.find(c => c.userData.id === state.selectedModuleId);
                if (moduleMesh) {
                    moduleMesh.position.set(snappedX, moduleState.position.y, snappedZ);
                    selectionBox.setFromObject(moduleMesh);
                }
            }
        }

        function onPointerUp() {
            controls.enabled = true;
            if (state.selectedModuleId) {
                calculateStats();
            }
            moveStartPosition = null;
        }

        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const moduleType = e.dataTransfer.getData('text/plain');
            if (!moduleType) return;

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                const pos = intersects[0].point;
                const snappedPos = {
                    x: Math.round(pos.x / 2) * 2,
                    z: Math.round(pos.z / 2) * 2
                };
                addModule(moduleType, snappedPos);
            }
        });

        // --- AI ADVISOR ---
        document.getElementById('analyze-button').addEventListener('click', async () => {
            if (!GEMINI_API_KEY) {
                showNotification("Error: Gemini API key not set.");
                return;
            }
            if (state.modules.length === 0) {
                showNotification("Add some modules before analyzing.");
                return;
            }

            const button = document.getElementById('analyze-button');
            const placeholder = document.getElementById('ai-placeholder');
            const loading = document.getElementById('ai-loading');
            const suggestion = document.getElementById('ai-suggestion');

            button.disabled = true;
            placeholder.classList.add('hidden');
            loading.classList.remove('hidden');
            suggestion.textContent = '';
            
            try {
                const simpleLayout = state.modules.map(m => ({ type: m.type, position: {x: m.position.x, z: m.position.z} }));
                const prompt = `
                  You are an expert NASA habitat design analyst. Your goal is to ensure astronaut safety, efficiency, and comfort.
                  Analyze the following space habitat layout provided in JSON format.
                  Habitat Layout: ${JSON.stringify(simpleLayout, null, 2)}
                  Based on this data, provide one critical, actionable suggestion to improve the layout. Focus on safety, energy efficiency, or crew workflow.
                  Keep your response concise and to the point (2-3 sentences max).
                `;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                const result = await response.json();
                const text = result.candidates[0].content.parts[0].text;
                suggestion.textContent = text;

            } catch (error) {
                console.error("Gemini API Error:", error);
                suggestion.textContent = "Could not get a suggestion. Please check the API key and console for errors.";
            } finally {
                button.disabled = false;
                loading.classList.add('hidden');
            }
        });

        // --- FIREBASE & DATA PERSISTENCE ---
        let app, db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        async function initFirebase() {
            return new Promise((resolve) => {
                try {
                    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            unsubscribe();
                            resolve();
                        } else {
                            try {
                                const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                                if (token) {
                                    await signInWithCustomToken(auth, token);
                                } else {
                                    await signInAnonymously(auth);
                                }
                            } catch (error) {
                                console.error("Authentication failed:", error);
                                userId = `local_${crypto.randomUUID()}`;
                                unsubscribe();
                                resolve(); 
                            }
                        }
                    });
                } catch (error) {
                    console.warn("Firebase not configured. Using local mode.");
                    userId = `local_${crypto.randomUUID()}`;
                    resolve();
                }
            });
        }

        async function saveLayout() {
            if (!userId) {
                showNotification("Error: Not authenticated.");
                return;
            }
            if (userId.startsWith('local_')) {
                localStorage.setItem(`habitect_layout_${appId}`, JSON.stringify(state.modules));
                showNotification("Layout saved to local browser storage.");
                return;
            }
            try {
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'layouts', userId);
                await setDoc(docRef, { layout: JSON.stringify(state.modules), timestamp: new Date() });
                showNotification("Habitat layout saved to database!");
            } catch (error) {
                console.error("Error saving layout:", error);
                showNotification("Failed to save layout.");
            }
        }

        async function loadLayout() {
            if (!userId) {
                showNotification("Error: Not authenticated.");
                return false;
            }
            if (userId.startsWith('local_')) {
                const savedLayout = localStorage.getItem(`habitect_layout_${appId}`);
                if (savedLayout) {
                    state.modules = JSON.parse(savedLayout);
                    showNotification("Layout loaded from local storage.");
                    return true;
                } else {
                    showNotification("No local layout found.");
                    return false;
                }
            }
            try {
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'layouts', userId);
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    state.modules = JSON.parse(docSnap.data().layout);
                    showNotification("Habitat layout loaded from database!");
                    return true;
                } else {
                    showNotification("No saved habitat found in the database.");
                    return false;
                }
            } catch (error) {
                console.error("Error loading layout:", error);
                showNotification("Failed to load layout.");
                return false;
            }
        }

        async function clearLayout() {
            if (state.modules.length === 0) return;
            state.modules = [];
            
            // In a real app, you might want a confirm dialog here.
            
            if (!userId) {
                showNotification("Cleared layout. Not authenticated.");
                syncSceneWithState();
                return;
            }
            if (userId.startsWith('local_')) {
                localStorage.removeItem(`habitect_layout_${appId}`);
                showNotification("Local layout cleared.");
                syncSceneWithState();
                return;
            }
            try {
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'layouts', userId);
                await deleteDoc(docRef);
                showNotification("Layout cleared from scene and database.");
            } catch (error) {
                console.error("Error clearing database entry:", error);
                showNotification("Layout cleared locally, but failed to clear from database.");
            } finally {
                syncSceneWithState();
            }
        }

        document.getElementById('save-button').addEventListener('click', saveLayout);
        document.getElementById('clear-button').addEventListener('click', clearLayout);

        // --- APPLICATION FLOW & INITIALIZATION ---
        function showMainApp() {
            startPage.classList.add('hidden');
            appDiv.classList.remove('hidden');
            if (!renderer) {
                initThreeJS();
                renderModuleLibrary();
            }
            syncSceneWithState(); 
        }

        function showStartPage() {
            appDiv.classList.add('hidden');
            startPage.classList.remove('hidden');
        }

        async function initialize() {
            startPageLoading.classList.remove('hidden');
            await initFirebase();
            startPageLoading.classList.add('hidden');

            backToStartButton.addEventListener('click', showStartPage);

            createNewButton.addEventListener('click', () => {
                state.modules = [];
                deselectModule();
                showMainApp();
            });

            loadSavedButton.addEventListener('click', async () => {
                loadSavedButton.disabled = true;
                loadSavedButton.textContent = 'Loading...';
                const success = await loadLayout();
                if (success) {
                    deselectModule();
                    showMainApp();
                }
                loadSavedButton.disabled = false;
                loadSavedButton.textContent = 'Load Saved Habitat';
            });
        }

        initialize();

    </script>
</body>
</html>

